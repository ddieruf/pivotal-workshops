[
{
	"uri": "/workshop/",
	"title": "PASW 101 and Steeltoe Cloud Native .NET Microservices Workshop  Workshop",
	"tags": [],
	"description": "",
	"content": " Pivotal Platform Architecture helps companies learn how to solve IT and engineering challenges. We encourage you to explore our workshops. Build the future with Pivotal!  PASW 101 and Steeltoe Cloud Native .NET Microservices Workshop Workshop\n  Workshop Concepts Advanced Features of Steeltoe Workshop Demos Introduction \u0026amp; Credentials Setup Desktop Environment Create .NET Core Microservice for Windows Explore Applications Manager Setup Auto-Scaling Add a New Route Continue Workshop Environment Variables User Provided Services with Steeltoe Include Steeltoe Actuators and Create a Custom Health Check App Manager with Management Actuators Steeltoe Dynamic Logging Continue Workshop Bind the Microsoft Azure Service Broker Consume the Microsoft Azure Service Broker in your application Push Microservice to PASW Continuing Your .NET Cloud Native Journey  "
},
{
	"uri": "/concepts/",
	"title": "Concepts",
	"tags": [],
	"description": "",
	"content": " Concepts Learn the basics, understand architectures, and fill-in the core-concepts behind the workshop.\n"
},
{
	"uri": "/demos/",
	"title": "Demos",
	"tags": [],
	"description": "",
	"content": " Demos Build architectures, and test the core-concepts behind the workshop.\n"
},
{
	"uri": "/concepts/advanced-steeltoe/",
	"title": "",
	"tags": [],
	"description": "",
	"content": "\n "
},
{
	"uri": "/demos/intro-creds/",
	"title": "",
	"tags": [],
	"description": "",
	"content": " Introduction \u0026amp; Credentials In today\u0026rsquo;s workshop you will get hands on experience creating a templated app in Visual Studio, reviewing the cloud foundry manifest, pushing the app to Pivotal Application Services, attaching an auto-scaler to the app, and trying out different routes.\nYour workshop proctor should have provided URL\u0026rsquo;s and credentials prior to beginning the labs. Please have this information handy for the next lab.\nYou will need:  API URL of your workshop Pivotal Cloud Foundry (PCF) foundation URL of App Manager User name and password to login to the foundation Org and Space associated with the user account  "
},
{
	"uri": "/demos/setup-environment/",
	"title": "",
	"tags": [],
	"description": "",
	"content": " Setup Desktop Environment Goal The labs in this workshop make use of Powershell, the Cloud Foundry cli (cf cli), and local environment variables. The following steps will confirm you have the correct configuration.\nPrerequisites  Visual Studio (min 2015) Web Browser (Chrome, Firefox, Edge, Safari)(Not Internet Explorer) Powershell Internet connection  Download and Validate cf cli  Download the cli.\n Unpack the zip file.\n Double click cf-installer.exe to begin installation.\n When prompted, click Install, then Finish\n To verify your installation, open powershell and type cf --version. If your installation was successful, the cf cli version is returned. You may need to restart your powershell window for the cli to work properly.\n  If you don\u0026rsquo;t have permission to install the cli, download the cli executable  Download the cli exe.\n Unpack the zip file.\n Copy the cf.exe executable to c:\\Windows\\System32 folder. (this is to add cf to your path env variable)\n To verify your installation, open powershell and type cf. If your installation was successful, the cf CLI help listing appears. You may need to restart the powershell window to see the cf cli help listing appear.\n  Save your creds and API URL to environment variables  Open a powershell window and type in the following commands. Remember to replace the values below with your student creds that were assigned to you.  $env:cf_api = \u0026quot;\u0026lt;PAS API URL\u0026gt;\u0026quot; $env:cf_username = \u0026quot;\u0026lt;Student User Name\u0026gt;\u0026quot; $env:cf_password = \u0026quot;\u0026lt;Student Password\u0026gt;\u0026quot;  Install the Steeltoe Visual Studio project templates  Download the VSIX templates installer.\n With Visual Studio closed, double click the downloaded file to install the templates.\n Once complete, open Visual Studio and choose File \u0026gt; New \u0026gt; Project \u0026gt; C# there should be additional Steeltoe and Cloud Foundry template listed.\n  Complete With the cf cli installed, your foundation credentials saved, and the Visual Studio templates loaded, you are ready to get started. Head on to the next lab.\n"
},
{
	"uri": "/demos/create-microservice-win/",
	"title": "",
	"tags": [],
	"description": "",
	"content": " Create a .NET Core Microservice for Windows Goal Using the installed Visual Studio templates, create a new app based on Steeltoe that is ready for Cloud Foundry Windows Diego cell.\nPrerequisites  Visual Studio (min 2015) Internet Access  Load the Steeltoe Template for Cloud Foundry  From the Visual Studio homepage, choose File then New then Project. This will bring up the \u0026ldquo;New Project\u0026rdquo; window.\n Choose Installed in the left panel and locate the search box at the top right. Type steeltoe in the search box. This will filter the installed project templates, to only those published by Steeltoe.\n In the main panel locate the template named Cloud Foundry w Steeltoe (.NET Core - Linux) and click it.\n Choose a name and location for the new project and click ok to create the project.\n Be patient while the project is loaded and all needed packages are downloaded.\n  Explore the project  The ValuesContoller class should be automatically opened. This class creates a few RESTful endpoints for use. Note the route that the class establishes: /api/values/ and /api/values/5. We will use these once the app is pushed to PASW.\n Open the manifest.yml file by double clicking. This file tells PASW how to containerize and deploy the app. It also provides details like how many instances to run, what services to bind, and establishes any custom environment variables.\n name: is the name of the app that you use to reference it from the cf cli or in App Manager. host: is part of the url to run the app. instances: is the number of instances that PASW should deploy, of this app. memory: is the amount of memory each app instance will be allowed. disk_quota: is the amount of disk storage each app instance will be allowed. buildpack: is how the app\u0026rsquo;s container should be created and configured (runtime \u0026amp; system env vars). stack: is what operating system to deploy the app instance to. env: are environment variables the app should use during execution.  In the manifest, change the value of name: and host: to be something authentic (like your name). Keep it alpha-numeric and use -(dash) as a space.\n Save the manifest file. The app is ready to be published and deployed to PASW!\n  Complete Now you have a .NET Core microservice ready for deployment. In the following step you will create the artifact and deploy.\n"
},
{
	"uri": "/demos/explore-appmanager/",
	"title": "",
	"tags": [],
	"description": "",
	"content": " Explore Applications Manager Goal Now that you\u0026rsquo;ve pushed an app, log in to App Manager and explore the many options available.\nPrerequisites  Internet Access Web Browser (Chrome, Firefox, Edge, Safari)(Not Internet Explorer)  Log in to App Manager  Open PAS Apps Manager web site provided in the Introduction slide.  Log in with the student account creds assigned workshop proctor..\n Once logged in, notice your Org and Space is automatically loaded.   Locate the home page of your app  Click your space name (on the left) to get a list of apps deployed in that space. You should see your app previously pushed.\n Click the name of your app to see all the details and options.\n This is the home page of your app. From here you can start/stop the app, manually scale the app instances, manage the services bound to the app, manage routes attached to the app, view the app\u0026rsquo;s logs, and (with Steeltoe) manage logging levels and see in depth debugging.\n  Explore the Marketplace  Click the \u0026ldquo;Marketplace\u0026rdquo; link (on the left).\n This is a listing of all the services available to bind with your app. [When applicable] a service has plans associated with them. You choose a plan, name the instance, and bind.\n You don\u0026rsquo;t have to bind a service directly to an app. Alternately, you can bind a service to a Space. This makes the service available for binding to all apps within, but lets the service settings be managed in one place.\n  "
},
{
	"uri": "/demos/attach-autoscaler/",
	"title": "",
	"tags": [],
	"description": "",
	"content": " Setup Auto-scaling Goal From the home page of your app, in App Manager, attach an autoscaler service to it with scaling rules.\nPrerequisites  Pushed app Internet Access Web Browser (Chrome, Firefox, Edge, Safari)(Not Internet Explorer)  Find the autoscaler service and bind to a space  Open the \u0026ldquo;Markeplace\u0026rdquo; of services within App Manager.\n Locate the \u0026ldquo;App Autoscaler\u0026rdquo; service and click on it. This will show you the \u0026ldquo;plans\u0026rdquo; associated with that service. In this case there is only one plan called \u0026ldquo;Standard\u0026rdquo;.\n Click the \u0026ldquo;Select This Plan\u0026rdquo; button.\n For configuration, provide the following:\n Instance Name: my-autoscaler Add To Space: \u0026lt;choose your student space name\u0026gt; Bind To App: [do not bind]  Once completed, click the \u0026ldquo;Create\u0026rdquo; button to create the service instance. You should see a green confirmation message at the top.  The web page will automatically refresh to the services listing for your Space.\n  Bind your app to the autoscaler  From the home page of your app, choose the \u0026ldquo;Service\u0026rdquo; tab.\n Click the \u0026ldquo;Bind Service\u0026rdquo; button to bring up a list of available services for binding.\n In the \u0026ldquo;Service to Bind\u0026rdquo; drop down, choose your new my-autoscaler service.\n Click \u0026ldquo;Bind\u0026rdquo; buton to complete the binding and close the window.\n Now your newly bound service is listed but it has not been activated.\n Click the \u0026ldquo;Overview\u0026rdquo; tab and now you should see an \u0026ldquo;Autoscaling\u0026rdquo; slider in the \u0026ldquo;web\u0026rdquo; panel.   Activate the autoscaler and set a scaling rule  Activate the autoscaler service by clicking the slider to the \u0026ldquo;on\u0026rdquo; position. Notice the \u0026ldquo;Manage Autoscaling\u0026rdquo; link is now active.\n Click the \u0026ldquo;Manage Autoscaling\u0026rdquo; link to bring up the manage window. The Window has the following areas:\n Instance limits minimum: the minimum number of instances that your app should be running. (In production this number should match the number of Availability Zones) Instance limits maximum: the maximum number of instance that you app could possibly scale to. Scaling rules: how PAS descides to scale your app up and down. Scheduled limits: optionaly you can schedule dates and times of a certain instance count Event history: a log of scaling events for your app.  The minimum should be set to 2 and the maximum should set to 3. Click the \u0026ldquo;Apply Changes\u0026rdquo; button if necessary. Close the Window.\n If it hasn\u0026rsquo;t happened already, in a few moments you will see your app instance increase from 1 to 2! Now your app is on the road to being highly available and resilient. Congrats!\n  If you turned the autoscaling off or changed the minimum instances to be 1, PAS will take care of every else. Just sit back and watch the show.\n"
},
{
	"uri": "/demos/add-route/",
	"title": "",
	"tags": [],
	"description": "",
	"content": " Add a New Route Goal From the home page of your app, in App Manager, add a second route to the app.\nPrerequisites  Pushed app Internet Access Web Browser (Chrome, Firefox, Edge, Safari)(Not Internet Explorer)  Add a new a route to your app  From the home page of your app, choose the \u0026ldquo;Route\u0026rdquo; tab. Notice there is one route attached to your app. It was created from the Host value in the app\u0026rsquo;s manifest.\n Click the \u0026ldquo;Map A Route\u0026rdquo; button, to bring up the manage routes window.\n The window gives you options for creating a new route or attaching an existing route to the app. Choose \u0026ldquo;Map a New Route\u0026rdquo; and provide a Hostname value. Keep it simple, with something unique that no one else will use (like your name).\n Click the \u0026ldquo;Map\u0026rdquo; button to create the route and automatically attach to your app. The window will close and you will see two routes listed, your existing and the one just created.\n  Now your app has 2 different URL\u0026rsquo;s associated with it. Easy! You can click either route name to open the app in a different browser window.\nIf you had chosen to \u0026ldquo;Map an Existing Route\u0026rdquo; to your app, you would have the option to choose an existing route in the same Space. Route sharing is limited to an app\u0026rsquo;s Space.\nWith more than one app attached to the same route, PAS will load balance requests based on the number of instances. For example, if app A and B are using the same route, app A is running 1 instance and app B is running 3 instances, then ~25% of the request traffic will go to app A and ~75% of the traffic will go to app B. This is a very easy way to transfer live traffic from one app version to another, as a zero downtime (blue/green) deployment!\n"
},
{
	"uri": "/demos/pasw-to-steeltoe-basics/",
	"title": "",
	"tags": [],
	"description": "",
	"content": " Next Steps Congratulations you\u0026rsquo;ve completed the PASW Workshop!\nNow that you are a cf push expert, it\u0026rsquo;s time to get in to some more advanced topics. Continue to learn and experience more about cloud-native best practices with the Steeltoe Framework. The following labs will get you hands-on deploying .NET microservices.\nIf you\u0026rsquo;ve run out of time and need to take a break, don\u0026rsquo;t forget all the other ways to lean about Pivotal and the Steeltoe Framework.\n  Pivotal Education Services Self Guided Learning Pivotal Workshops     The Platform Acceleration Lab (PAL) is an immersive, best practices set of courses that enables developers and architects to develop new applications, move applications (replatforming), and modernize existing applications on Pivotal Cloud Foundry. The PAL is designed to enable through \u0026ldquo;doing it\u0026rdquo; rather than \u0026ldquo;talking about it.\u0026rdquo; In the 4 day .NET Cloud Native Developer course, students will gain a deep understanding of all Steeltoe packages. They will be hands-on coding an application, adding each package step by step. Through a combination of a free account with Pivotal Web Services and the many Steeltoe samples available, you can continue learning cloud native best practices and about all the framework has to offer. Speak with the Workshop Proctor to bring other cloud native inspired workshops to your organization. Topics like the Steeltoe Framework, all about BOSH, and microservices security are just a few of the suggested options.   \n"
},
{
	"uri": "/demos/env-vars-win/",
	"title": "",
	"tags": [],
	"description": "",
	"content": " Cloud Native - Environment Variables Goal Environment variables are a staple of cloud native best practices, but if you\u0026rsquo;ve been developing on a Windows desktop you may not be that familiar. This lab aims to introduce how a cloud native .NET app should hold very little configuration within, and instead rely on it\u0026rsquo;s configuration to be provided in environment variables.\nPrerequisites  Visual Studio (min 2015) Internet Access Web Browser (Chrome, Firefox, Edge, Safari)(Not Internet Explorer) Powershell  Create a new Visual Studio Steeltoe project  From the Visual Studio homepage, choose File \u0026gt; New \u0026gt; Project. This will bring up the \u0026ldquo;New Project\u0026rdquo; window.\n Choose Installed in the left panel and locate the search box at the top right. Type steeltoe in the search box. This will filter the installed project templates, to only those published by Steeltoe.\n In the main panel locate the template named Cloud Foundry w Steeltoe (.NET Core - Win) and click.\n Choose a name and location for the new project and click ok to create the project.\n Be patient while the project is loaded and all needed packages are downloaded.\n  Add environment variables in the app manifest  Open the manifest.yml file by double clicking. This file tells PASW how to containerize and deploy the app. It also provides details like how many instances to run, what services to bind, and establishes any custom environment variables.\n Locate the env area to the manifest and add the MYAPP_CONNECTION_STRING variable. Leave the other environment variables as is.\ninstances: 1 memory: 512M disk_quota: 512M ... env: MYAPP_CONNECTION_STRING: 'Server=FQDNServerAddress;Database=myDataBase;User Id=myUsername;Password=myPassword;'  Each time an instance of the app is deployed, these environment variables will be created and made available to the app. In the turn the app will use the provided values to do some work.\n  Retrieve the environment variable values in the app  Locate the Program.cs file and double click it, to open.\n Add a direction for all environment variables with the prefix \u0026ldquo;MYAPP_\u0026rdquo; to be loaded into the app\u0026rsquo;s configuration collection (Microsoft.Extensions.Configuration).\nWebHost.CreateDefaultBuilder(args) ... .ConfigureAppConfiguration((hostingContext, config) =\u0026gt; { config.AddEnvironmentVariables(prefix: \u0026quot;MYAPP_\u0026quot;); });  Locate the Controllers\\ValuesController.cs file and double click it, to open.\n Add a class variable to hold the app\u0026rsquo;s configuration.\npublic class ValuesController : ControllerBase { ... private readonly IConfiguration _configuration;  Inject configuration in to the class constructor and fill the newly created variable.\npublic ValuesController(IOptions\u0026lt;CloudFoundryApplicationOptions\u0026gt; appOptions, IOptions\u0026lt;CloudFoundryServicesOptions\u0026gt; serviceOptions, ILogger\u0026lt;ValuesController\u0026gt; logger, IConfiguration configuration) { ... _configuration = configuration; ... }  Locate the [HttpGet] endpoint, retrieve the environment variable and return its value when the endpoint is called.\n[HttpGet] public ActionResult\u0026lt;IEnumerable\u0026lt;string\u0026gt;\u0026gt; Get() { ... string myConnectionString = _configuration[\u0026quot;CONNECTION_STRING\u0026quot;]; return new string[] { myConnectionString }; }   Complete Now instead of the app\u0026rsquo;s connection string being saved in its web.config or being hard coded in the app, it\u0026rsquo;s being provided at run time. This opens quite a few cloud native \u0026ldquo;doors\u0026rdquo; for us. We can build the app once and move it through different spaces (or environments), each providing a different backing data store (in the form of a connection string).\nAlright! Now you\u0026rsquo;re ready to publish and test the newly configured endpoint.\n"
},
{
	"uri": "/demos/cups/",
	"title": "",
	"tags": [],
	"description": "",
	"content": " User Provided Services with Steeltoe Goal Environment variables are a very powerful feature of cloud native applications but sometimes we need all the apps in a given space (or environment) to share settings. User provided services are a great way to accomplish this. In this lab we will create a service that is available to all apps in a given space via environment variables.\nNote, this lab assumes you already have the Steeltoe template app opened in Visual Studio and you have already logged in to a foundation with the cf cli.\nPrerequisites  Visual Studio (min 2015) Powershell  Create a User Provided Service  Confirm the Org/Space you are currently targeting by opening a powershell window and run cf target. The cli should return the names of the Org and Space that will be the target of any commands issued. (If you\u0026rsquo;ve been logged out, it will let you know that as well)\n Create a User Provided Service by running the provided command.\ncf create-user-provided-service 'app-connection-string' -p '{\\\u0026quot;CONNECTION_STRING\\\u0026quot;:\\\u0026quot;Server=FQDNServerAddress_cups;Database=myDataBase;User Id=myUsername;Password=myPassword;\\\u0026quot;}'  Confirm the service is available for binding by listing all services in the space cf services. You should see the app-connection-string service listed.\n  Bind the app to the new service  To have the new service bound to the app, we will add the direction to the manifest. Open the manifest.yml file by double clicking and add the following section. ```yml instances: 1 memory: 512M disk_quota: 512M \u0026hellip; services:\n app-connection-string ```  By having the service bound to the app, the environment variable CONNECTION_STRING will automatically be made available. To consume this variables value, we can use the Steeltoe Cloud Foundry Provider.\n If you previously did the \u0026ldquo;Environment Variables\u0026rdquo; lab, we can remove some of those steps from the code.\n Remove the following lines from Program.cs.\n.ConfigureAppConfiguration((hostingContext, config) =\u0026gt; { config.AddEnvironmentVariables(prefix: \u0026quot;MYAPP_\u0026quot;); })  Remove the configuration provisions from Controllers\\ValuesController.cs.\nprivate readonly IConfiguration _configuration;  public ValuesController(IOptions\u0026lt;CloudFoundryApplicationOptions\u0026gt; appOptions, IOptions\u0026lt;CloudFoundryServicesOptions\u0026gt; serviceOptions, ILogger\u0026lt;ValuesController\u0026gt; logger) { ... }   The Cloud Foundry Provider has already been provisioned in the Controllers\\ValuesController.cs class. Notice the class variables _appOptions and _serviceOptions. Which makes consuming the value of the bound User Provided Service very easy!\n Locate the [HttpGet] endpoint and replace the value of \u0026ldquo;myConnectionString\u0026rdquo; with a lookup using the _serviceOptions collection.\n[HttpGet] public ActionResult\u0026lt;IEnumerable\u0026lt;string\u0026gt;\u0026gt; Get() { ... string myConnectionString = _serviceOptions.Services[\u0026quot;user-provided\u0026quot;] .First(q =\u0026gt; q.Name.Equals(\u0026quot;app-connection-string\u0026quot;)) .Credentials[\u0026quot;CONNECTION_STRING\u0026quot;].Value; return new string[] { myConnectionString }; }  Steeltoe knows how Cloud Foundry makes environment variables available to apps,\n  Complete Simple! While it may not appear to be using environment variables, \u0026ldquo;behind the scenes\u0026rdquo; Steeltoe is aware of how Cloud Foundry makes services available to apps. So the \u0026ldquo;CloudFoundryServicesOptions\u0026rdquo; package did all the hard work of parsing values.\nIn our app\u0026rsquo;s case, it parsed the provided values into the _serviceOptions collection. Then we did a look up in the collection to find the first service with the name \u0026ldquo;app-connection-string\u0026rdquo;. Within that service we retrieved the value for the label \u0026ldquo;CONNECTION_STRING\u0026rdquo;.\nIf we created the same User Provided Service in each of your Org Spaces (aka environments). You might have Dev, Test, and Pre-Prod spaces. The app can then be moved between spaces with no change - as along as each space has the same service name. But! the value of the service would change between each space depending on what tests needs to be run. The Dev space is using a datastore with junk data, the Test space is using a datastore with limited access and clean data, and the Pre-Prod space has a similar datastore to Test but with even less access.\nBuild once and promote through environments! Thats cloud native.\n"
},
{
	"uri": "/demos/actuators/",
	"title": "",
	"tags": [],
	"description": "",
	"content": " Include Steeltoe Actuators and Create a Custom Health Check Goal Assuming you have already pushed an app based on the Steeltoe Cloud Foundry templates, this lab will review what additions were made in the project to enable Actuators and the automatic benefits in App Manager.\nPrerequisites  Visual Studio (min 2015) Internet Access Web Browser (Chrome, Firefox, Edge, Safari)(Not Internet Explorer)  Add Steeltoe Management Actuators to the app  Open the Startup.cs file by double clicking.\n Confirm the Management package is implemented.\nusing Steeltoe.Management.CloudFoundry;  In the ConfigureServices method, confirm the default actuator endpoints have been initialized.\npublic void ConfigureServices(IServiceCollection services) { services.AddCloudFoundryActuators(Configuration); ... }  In the Configure method, confirm the default actuator endpoints have been implemented.\npublic void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory) { app.UseCloudFoundryActuators(); app.UseMvc(); ... }  Now say to yourself \u0026ldquo;wow that was easy\u0026rdquo;, because thats all you need to do, to get the default actuators going! To lean more about what is included in the default endpoints, have a look at the Steeltoe management usage documentation.\n  Extend app health check to include a custom check Before we switch to App Manager and see all the wonderful benefits of actuators, let\u0026rsquo;s customize things a little. One very useful actuator is the /health endpoint. This helps BOSH determine an app\u0026rsquo;s health and weather it needs to be recycled. Lets extend the default health check to include a custom check.\n Create a new C# class in the app project, named CustomHealthContributor.cs. It can be located in the root of the project with the Project.cs and Statup.cs files.\n If Visual Studio did not automatically open the new file, do so by by double clicking.\n Add a reference to the HealthChecks package.\nusing Steeltoe.Common.HealthChecks;  Extend the CustomHealthContributor class with the IHealthCheckContributor.\n... public class CustomHealthContributor : IHealthContributor { ...  Within the class add a public Id property and add the Health method with some very basic status reporting.\npublic string Id =\u0026gt; \u0026quot;CustomHealthContributor\u0026quot;; public HealthCheckResult Health(){ var result = new HealthCheckResult { Status = HealthStatus.UP, Description = \u0026quot;This health check does not check anything, yet!\u0026quot; }; result.Details.Add(\u0026quot;status\u0026quot;, HealthStatus.UP.ToString()); //a part of the middleware response return result; }  Your CustomHealthContributor class should look like the following. Not the check isn\u0026rsquo;t actually checking anything at the moment. It\u0026rsquo;s just an example :).\npublic class CustomHealthContributor : IHealthContributor { public string Id =\u0026gt; \u0026quot;CustomHealthContributor\u0026quot;; public HealthCheckResult Health() { var result = new HealthCheckResult { // this is used as part of the aggregate, it is not directly part of the middleware response Status = HealthStatus.UP, Description = \u0026quot;This health check does not check anything\u0026quot; }; result.Details.Add(\u0026quot;status\u0026quot;, HealthStatus.UP.ToString()); return result; } }  Open the Startup.cs file, by double clicking.\n Add a reference to the HealthChecks Steeltoe package.\nusing Steeltoe.Common.HealthChecks;  In the ConfigureServices method, register the new custom health check as a singleton.\npublic void ConfigureServices(IServiceCollection services) { ... services.AddSingleton\u0026lt;IHealthContributor, CustomHealthContributor\u0026gt;(); }   Complete Along with the default Cloud Foundry health checks, we have added in the possibility to report an additional check on some custom serivce or object. You can read more about what healthchecks are built in, in the Steeltoe health documentation.\nNext up, push the app to the foundation and explore all the cool things that get enabled in App Manager.\n"
},
{
	"uri": "/demos/using-actuators/",
	"title": "",
	"tags": [],
	"description": "",
	"content": " App Manager with Management Actuators Goal Now that you have pushed an app to the foundation that implments Steeltoe Actuators, lets explore how App Manager makes that data available for debugging and analysis.\nPrerequisites  Internet Access Web Browser (Chrome, Firefox, Edge, Safari)(Not Internet Explorer)  Discover how App Manager works with each actuator endpoint  Open the App Manager website in a browser.\n Navigate to your app\u0026rsquo;s home page.\n Notice your app has been given the Steeltoe icon. Congratulations! This is because the app registered CloudFoundry aware endpoints with the platform, so App Manager automatically hooked everything up.\n On the app\u0026rsquo;s home page, locate the \u0026ldquo;web\u0026rdquo; area where your running app instances are listed. Notice there is now an option to expand each app instance to review its health, and the custom health check added previously is listed.  Now click the Trace tab at the top of the panel.\n If you were to send a few GET requests to the app and refresh this area, you would see a trace of those requests. Information incldes the resulting HTTP status and the Request/Response headers.  Locate the Settings tab at the top of the panel and click.\n Find the Mappings area and click the \u0026ldquo;View Mappings\u0026rdquo; button. This will popup a list of all the dicovered routes and route templates within the app.   Complete There\u0026rsquo;s one more piece of Steeltoe and it\u0026rsquo;s integrations with App Manager to discover and that\u0026rsquo;s around message logging. The next lab will over that topic.\n"
},
{
	"uri": "/demos/logging/",
	"title": "",
	"tags": [],
	"description": "",
	"content": " Steeltoe Dynamic Logging Goal Assuming you have already pushed an app based on the Steeltoe Cloud Foundry templates, this lab will review what additions were made in the project to enable dynamic logging and the automatic benefits in App Manager.\nPrerequisites  Visual Studio (min 2015) Internet Access Web Browser (Chrome, Firefox, Edge, Safari)(Not Internet Explorer)  Enable Steeltoe dynamic logging  There are additional features that came pre-configured in the Steeltoe template app. Open the Program.cs file by double clicking.\n Notice the ConfigureLogging section within IWebHostBuilder has an added Steeltoe DynamicLogger package to the Microsoft Console logging provider.\n.ConfigureLogging((builderContext, loggingBuilder) =\u0026gt; { // Add Steeltoe Dynamic Logging provider loggingBuilder.AddDynamicConsole(); })  Open the ValuesController.cs file in the \u0026ldquo;Controllers\u0026rdquo; folder, by double clicking. Note the custom log entries being written.\n_logger.LogInformation(\u0026quot;Hi There\u0026quot;);   You can write log entries with no special packages, using the C# Microsoft.Extensions.Logging.ILogger package. There are options like logging Critical, Error, Warning, Info entries. Because Steeltoe DynamicLogger has been enabled to monitor these custom app logs, everything is written within App Manager and Metrics for review - automatically!\nDiscover and use dynamic logging in App Manager  Open the App Manager website in a browser.\n Navigate to your app\u0026rsquo;s home page.\n Now click the Logs tab at the top of the panel.\n Adjust the logging level by clicking the \u0026ldquo;Configure Logging Levels\u0026rdquo; button. This window gives you the ability to turn logging verbosity up or down, depending on the package.   In the above screen shot, logging was enabled for the \u0026ldquo;Microsoft.AspNetCore.Mvc\u0026rdquo; package. Now as new requests are made, you can see deeper log detail with every request about how the route template was calculated - see the log entry Route matched with {action = \u0026quot;Get\u0026quot;, controller = \u0026quot;Values\u0026quot;}. in the below image. Complete Dynamic logging is a very powerful tool while in development and even more powerful for production. Now you can turn things up when there\u0026rsquo;s a issue and consume those messages not only in App Manager but also in whatever logging platform the foundation has been provided (splunk, etc). Then turn it back down when everything is ok.\n"
},
{
	"uri": "/demos/steeltoe-basics-to-steeltoe-aszure-storage/",
	"title": "",
	"tags": [],
	"description": "",
	"content": " Next Steps Congratulations you\u0026rsquo;ve completed the Steeltoe basics Workshop!\nContinue to learn and experience more about cloud-native best practices by using the Azure SQL broker with Steeltoe Framework. The following labs will get you hands-on..\nIf you\u0026rsquo;ve run out of time and need to take a break, don\u0026rsquo;t forget all the other ways to lean about Pivotal and the Steeltoe Framework.\n  Pivotal Education Services Self Guided Learning Pivotal Workshops     The Platform Acceleration Lab (PAL) is an immersive, best practices set of courses that enables developers and architects to develop new applications, move applications (replatforming), and modernize existing applications on Pivotal Cloud Foundry. The PAL is designed to enable through \u0026ldquo;doing it\u0026rdquo; rather than \u0026ldquo;talking about it.\u0026rdquo; In the 4 day .NET Cloud Native Developer course, students will gain a deep understanding of all Steeltoe packages. They will be hands-on coding an application, adding each package step by step. Through a combination of a free account with Pivotal Web Services and the many Steeltoe samples available, you can continue learning cloud native best practices and about all the framework has to offer. Speak with the Workshop Proctor to bring other cloud native inspired workshops to your organization. Topics like the Steeltoe Framework, all about BOSH, and microservices security are just a few of the suggested options.   \n"
},
{
	"uri": "/demos/bind-sb/",
	"title": "",
	"tags": [],
	"description": "",
	"content": " Bind the Microsoft Azure Service Broker Goal Locate the Azure SQL in the Marketplace and make an instance of it available for binding in your space.\nPrerequisites  Internet Access Web Browser (Chrome, Firefox, Edge, Safari)(Not Internet Explorer)  Bind the Azure SQL service to your space  Open the App Manager website in a browser.\n Navigate to the \u0026ldquo;Marketplace\u0026rdquo; in the left navigation.\n Local the \u0026ldquo;Azure SQL Database Service\u0026rdquo; and click.  Choose the \u0026ldquo;Basic\u0026rdquo; plan and click the \u0026ldquo;Select This Plan\u0026rdquo; button.\n Provide the following for Instance Configuration Instance Name: my-azure-db Add To Space: Bind To App: [do not bind]\n Click the \u0026ldquo;Create\u0026rdquo; button to create the instance and make it available for binding.\n Navigate the to the home page of your space and click the \u0026ldquo;Services\u0026rdquo; tab. You should see the Azure SQL Database Service listed. Confirm everything as successful by noting the right column message \u0026ldquo;create succeeded\u0026rdquo;.  There is no further configuration required! You are ready to consume the database in an application.\n  Complete You have taken a service offered in the Marketplace and associated an instance of it, with your space. Now apps within the space can bind to the service and this consume it. Let\u0026rsquo;s say you had a \u0026ldquo;Dev\u0026rdquo; space and a \u0026ldquo;QA\u0026rdquo; space. If you bound the Azure SQL Database Service to each space and named each instance the same, your app could move to either space with no config changes! All it depends on is the serivce to be available for binding, no evironment or web.config dependencies.\nBy the way using the cf cli, we could have accomplished everything above in powershell with:\ncf create-service azure-sqldb basic my-azure-db  "
},
{
	"uri": "/demos/dbcontext/",
	"title": "",
	"tags": [],
	"description": "",
	"content": " Consume the Microsoft Azure Service Broker in your application Goal With the Azure SQL service available for binding, create the necessary DBContext and list the newly created tables\u0026rsquo; content.\nPrerequisites  Visual Studio (min 2015) Internet Access  Bind the SQL service to your application  Back in Visual Studio, open the manifest.yml file by double clicking and add the following to the services section (create that section if it\u0026rsquo;s not there). ```yml\n\u0026hellip;\nservices:\n my-azure-db ```   Add SQL DBContext  Open Program.cs and confirm the Cloud Foundry provider has been added. This provider gives your app the ability to locate the VCAP environment variables that are created by Cloud Foundry, and parse them.\nWebHost.CreateDefaultBuilder(args) ... .UseCloudFoundryHosting() .AddCloudFoundry() .UseStartup\u0026lt;Startup\u0026gt;() ...  You may need to add the dependency\nusing Steeltoe.Extensions.Configuration.CloudFoundry;  Create a new class file named TestContext.cs and replace the default class with the following code.\nusing Microsoft.EntityFrameworkCore; using System.ComponentModel.DataAnnotations; using System.ComponentModel.DataAnnotations.Schema;  ```cs public class TestContext : DbContext { public TestContext(DbContextOptions options) : base(options){ }\npublic DbSet TestData { get; set; } }\n  public class TestData { [Key] [DatabaseGenerated(DatabaseGeneratedOption.Identity)] public int Id { get; set; }\npublic string Data { get; set; }  }\n 1. Create a new class file named `SampleData.cs` and replace the default class with the following code. This will initialize the a database table using the TestData schema and fill it with 2 rows of data, if none exists. ```cs using Microsoft.EntityFrameworkCore; using Microsoft.Extensions.DependencyInjection; using System; using System.Linq;  public class SampleData { internal static void InitializeMyContexts(IServiceProvider serviceProvider) { if (serviceProvider == null) { throw new ArgumentNullException(\u0026quot;serviceProvider\u0026quot;); } using (var serviceScope = serviceProvider.GetRequiredService\u0026lt;IServiceScopeFactory\u0026gt;().CreateScope()) { var db = serviceScope.ServiceProvider.GetService\u0026lt;TestContext\u0026gt;(); db.Database.EnsureCreated(); } InitializeContext(serviceProvider); } private static void InitializeContext(IServiceProvider serviceProvider) { using (var serviceScope = serviceProvider.GetRequiredService\u0026lt;IServiceScopeFactory\u0026gt;().CreateScope()) { var db = serviceScope.ServiceProvider.GetService\u0026lt;TestContext\u0026gt;(); if (db.TestData.Any()) { return; } AddData\u0026lt;TestData\u0026gt;(db, new TestData() { Data = \u0026quot;Test Data 1 - TestContext \u0026quot; }); AddData\u0026lt;TestData\u0026gt;(db, new TestData() { Data = \u0026quot;Test Data 2 - TestContext \u0026quot; }); db.SaveChanges(); } } private static void AddData\u0026lt;TData\u0026gt;(DbContext db, object item) where TData: class { db.Entry(item).State = EntityState.Added; } }   Locate the Controllers\\ValuesController.cs file and double click it, to open. Find the [HttpGet] endpoint and Replace the method logic with the following.\n[HttpGet] public ActionResult\u0026lt;IEnumerable\u0026lt;TestData\u0026gt;\u0026gt; Get([FromServices] TestContext context) { var connection = context.Database.GetDbConnection(); return context.TestData.ToList(); }  You may need to add the dependency\nusing System.Collections.Generic;  Open Startup.cs and locate the ConfigureServices method. Add our newly created database context.\npublic void ConfigureServices(IServiceCollection services) { ... services.AddDbContext\u0026lt;TestContext\u0026gt;(options =\u0026gt; options.UseSqlServer(Configuration)); services.AddMvc(); }  You may need to add the dependency\nusing Steeltoe.CloudFoundry.Connector.SqlServer.EFCore;   Complete The app is ready for prime time. You have retrieved the serivce information (with connection info) from the provided environment variables, create a database context, initialized the data store, and made querying available via RESTFul endpoint.\n"
},
{
	"uri": "/demos/push-microservice/",
	"title": "",
	"tags": [],
	"description": "",
	"content": " Push the Microservice to Pivotal Application Services Platform Goal Using Visual Studio, compile the app to create an artifact. Then push the artifact to the Platform, for deployment.\nPrerequisites  Visual Studio (min 2015) PAS API Access PAS App Manager Access  Create the App Artifact  With the Steeltoe Microservice app opened in Visual Studio, right click on the project name and choose publish. (No need to build or restore, it will happen automatically)  The \u0026ldquo;Publish\u0026rdquo; window will open where you can choose the FolderProfile. Let the other settings remain as default.  Click the Publish button to create a new app artifact. Visual Studio will provide feedback about restoring packages and building the project. Something simiar to:\n 1\u0026gt; Steeltoe-CloudFoundry-Template1 -\u0026gt; C:\\tmp\\Steeltoe-CloudFoundry-Template1\\bin\\Steeltoe-CloudFoundry-Template1.dll 2\u0026gt;------ Publish started: Project: Steeltoe-CloudFoundry-Template1, Configuration: Release x64 ------ 2\u0026gt;Connecting to C:\\tmp\\Steeltoe-CloudFoundry-Template1\\bin\\Release\\Publish... 2\u0026gt;Deleting existing files... 2\u0026gt;Publishing folder /... 2\u0026gt;Publishing folder bin... 2\u0026gt;Web App was published successfully file:///C:/tmp/Steeltoe-CloudFoundry-Template1/bin/Release/Publish 2\u0026gt; ========== Build: 1 succeeded, 0 failed, 0 up-to-date, 0 skipped ========== ========== Publish: 1 succeeded, 0 failed, 0 skipped ==========  In the output window, note the location of the newly created artifact. Your location will be a little different, but in the above example it\u0026rsquo;s C:/tmp/Steeltoe-CloudFoundry-Template1/bin/Release/Publish. This folder has the compiled DLL, runtime dependencies, and the PAS manifest. That is your artifact!\n  Log in to PAS  Open a powershell window.\n Log in to PAS. You can copy and paste the following command into your powershell window to login. This command requires that you have setup the environment variables discussed earlier.\n   cf login -a $env:cf_api -u $env:cf_username -p $env:cf_password  If necessary, you can validate the existence of environment variables with the following commands: ```powershell  Get-ChildItem env:cf_api Get-ChildItem env:cf_username Get-ChildItem env:cf_password ```\n You may be prompted to choose an Org and Space. Choose the organization and space specified by your proctor. If you are not prompted, by default your Org and Space have already been set.\n To confirm you have targeted the correct Org and Space, type cf target. The output of this command will be similar to the following:\nPS C:\\\u0026gt; cf target api endpoint: https://api.system.pcf.acme.io api version: 2.120.0 user: wcoyote@acme.io org: my-micro-service-1 space: sandbox  The Org and Space are where your app will be pushed to. To target a specific organization and space use the following command:\ncf target -o \u0026lt;specify org\u0026gt; -s \u0026lt;specify space\u0026gt;   Push the Artifact With the app artifact created, the appropriate Org and Space targeted in PAS, you are ready to push!\n In the powershell window, cd into the directory holding the artifact. This is the directory you published into from Visual Studio. Example:\nPS C:\\\u0026gt; cd C:/tmp/Steeltoe-CloudFoundry-Template1/bin/Release/Publish  In the powershell window, type the command cf push. Your Artifact will be staged in a temporary place on PAS, containerized, deployed, and a route bound to it. Easy!\nrequested state: started instances: 1/1 usage: 1G x 1 instances urls: my-app-host-name.domain.com last uploaded: Mon Jan 7 01:01:10 UTC 2000 stack: windows2016 buildpack: binary state since cpu memory disk details #0 running 2000-01-01 01:01:01 PM 231.0% 498.1M of 1G 161.9M of 1G (10)  Validate that the microservice is running. The microservice URL is the URL output in the previous step plus the suffix of /api/values/5. For example, the above output had the URL as my-app-host-name.domain.com and the associated microservice URL would be https://my-app-host-name.domain.com/api/values/5. Open this URL in your browser to see the microservice in action.\n  Complete Congratulations! You\u0026rsquo;ve pushed your first app!\n"
},
{
	"uri": "/demos/next-steps/",
	"title": "",
	"tags": [],
	"description": "",
	"content": " Continuing Your .NET Cloud Native Journey Congratulations you\u0026rsquo;ve completed Steeltoe Azure Storage Workshop!\nContinue to learn and experience more about cloud native best practices, with Pivotal.\n  Pivotal Education Services Self Guided Learning Pivotal Workshops     The Platform Acceleration Lab (PAL) is an immersive, best practices set of courses that enables developers and architects to develop new applications, move applications (replatforming), and modernize existing applications on Pivotal Cloud Foundry. The PAL is designed to enable through \u0026ldquo;doing it\u0026rdquo; rather than \u0026ldquo;talking about it.\u0026rdquo; In the 4 day .NET Cloud Native Developer course, students will gain a deep understanding of all Steeltoe packages. They will be hands-on coding an application, adding each package step by step. Through a combination of a free account with Pivotal Web Services and the many Steeltoe samples available, you can continue learning cloud native best practices and about all the framework has to offer. Speak with the Workshop Proctor to bring other cloud native inspired workshops to your organization. Topics like the Steeltoe Framework, all about BOSH, and microservices security are just a few of the suggested options.   \n"
},
{
	"uri": "/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/",
	"title": "Pivotal Workshop",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]